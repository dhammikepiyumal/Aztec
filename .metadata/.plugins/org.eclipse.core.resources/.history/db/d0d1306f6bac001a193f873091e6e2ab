package com.dhammikepiyumal.aztec;

import java.awt.Canvas;
import java.awt.Dimension;
import java.awt.image.BufferStrategy;
import javax.swing.JFrame;

public class Game extends Canvas implements Runnable {
	public static int width = 300;
	public static int height = width / 16 * 9;
	public static int scale = 3;

	private static final long serialVersionUID = 1L;
	private Thread thread;
	private JFrame frame;
	private boolean running = false;

	public Game() {
		Dimension size = new Dimension(width * scale, height * scale);
		setPreferredSize(size);

		frame = new JFrame();
	}

	public synchronized void start() {
		running = true;
		thread = new Thread(this, "Display");
		thread.start();
	}

	public synchronized void stop() {
		running = false;
		try {
			thread.join();
		} catch (final InterruptedException e) {
			e.printStackTrace();
		}
	}

	public void run() {
		while (running) {
			update();
			render();
		}
	}

	public void update() {

	}

	public void render() {
		BufferStrategy bs = getBufferStrategy();

		if (bs == null) {
			createBufferStrategy(3);
			return;
		}
	}

	public static void main(String[] args) {
		Game game = new Game();
		game.frame.setResizable(false);
		game.frame.setTitle("Rain");
		game.frame.add(game);
		game.frame.pack();
		game.frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		game.frame.setLocationRelativeTo(null);
		game.frame.setVisible(true);

		game.start();
	}
}

/*
 * 'Canvas' can be called as a window which the programmer can manipulate in any
 * manner
 */
/*
 * 'Runnable' allows the Game class to be used as a thread process
 */
/*
 * 'width' and 'height' are the dimensions of the window.
 */
/*
 * 'scale' is the factor that the window is to be stretched
 */
/*
 * 'private static final long serialVersionUID = 1L' is added as the 'Game'
 * class extends the 'Canvas' class. It is some kind of a convention in Java to
 * add it
 */
/*
 * A 'thread' can be called as sub process other than the main process of
 * running the program. Here it is used to keep the game process of running the
 * game separated from the main process of executing the program
 */
/*
 * 'JFrame' is basically a type of Window. There are other types of Windows
 */
/*
 * 'Dimension' is a way of providing coordinates in java
 */
/*
 * 'running' is the condition that keeps the Game loop running
 */
/*
 * 'synchronized' is used to prevent the interferences between the threads and
 * to avoid memory consistency errors
 */
/*
 * 'thread = new Thread(this, "Display')' means passing this game class to
 * create a new thread object and provide it with the name 'Display'
 */
/*
 * 'thread.join()' is joining all the threads together to perform a certain task
 * applying the result for all of them. example : Stop running all the threads
 * to stop the program running
 */
/*
 * 'e.printStackTrace()' is used to print the error message if a certain error
 * has encountered
 */
/*
 * 'update()' hadles the logic and basically it updates the game. This is
 * planned to be restricted to 60 frames per second
 */
/*
 * 'render()' is displaying images in the screen. This is not going to be
 * restricted.
 */
/*
 * 'BufferStratergy' comes from the 'Canvas' and it is basically used as a
 * container to store the pre rendered images that need to be put on to the
 * window next. This is done due to the fact that real time updating of the
 * screen is not practical. Pre rendered image is kept at the buffer for about
 * 1/60 of a second.
 */
/*
 * 'getBufferStratergy()' returns if there is already defined 'BufferStratergy'.
 * If it returns 'null', then 'createBufferStratergy(3)' creates a buffer
 * stratergy. 3 here is the usual standard to go. Whatr happens in here is that
 * we are creating 3 images at the same time. The one which is visible and two
 * other windows which are yet to come to the window. 3 is usually used for the
 * smooth running of the game. By going higher than 3, there is no actual real
 * world advantage.
 */
/*
 * 'add' is used to add the game component to the window
 */
/*
 * 'pack' is used to size up the frame to be the same size of the component
 */
/*
 * 'setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE)' is simply says terminate the
 * application when the close button on the top right corner of the window is
 * pressed
 */
/*
 * 'setLocationRealativeTo(null)' is making the window stay at the center of the
 * frame
 */
/*
 * 'setVisible(true)' is actually making the window visible on the screen to be
 * seen by the viewers
 */